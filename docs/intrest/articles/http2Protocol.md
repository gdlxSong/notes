---
title: "http2 Protocol RFC7540"
date: 2020-06-08T11:43:12+08:00
lastmod: 2020-06-08T11:43:12+08:00
description: ""
tags: ["rfc", "http", "转载"]
categories: ["http"]
author: "xGdl"
comment: true
toc: true
autoCollapseToc: true
postMetaInFooter: false
hiddenFromHomePage: false
contentCopyright: true
reward: true
mathjax: true
mathjaxEnableSingleDollar: false
mathjaxEnableAutoNumber: false
---

## 简介

>原文链接:https://datatracker.ietf.org/doc/rfc7540/

`关于http协议的基础知识请参照前面的文章《http协议》`


通过引入头部字段压缩并允许在同一连接上进行多个并发交换，HTTP/2可以更有效地使用网络资源，并减少对延迟的感知。 它还介绍了从服务器向客户端主动提供表示的情况。 此规范是HTTP/1.1消息语法的替代，但不会过时。 `HTTP的现有语义保持不变。`

超文本传输​​协议（HTTP）是一个非常成功的协议。但是，HTTP/1.1使用底层传输的方式（[RFC7230]，第6部分）有几个特性会对当今的应用程序性能产生负面影响。特别是，

	`HTTP/1.0在给定的TCP连接上一次只允许一个请求。 `
	`HTTP/1.1添加了请求流水线，但是这只能部分解决请求并发性，并且仍然受到头部阻塞的影响。`

因此，需要发出很多请求的HTTP/1.0和HTTP/1.1客户端使用多个连接到服务器，以实现并发性，从而减少延迟。此外，

	HTTP标头字段通常是重复的和冗长的，

导致不必要的网络流量以及导致初始TCP [TCP]拥塞窗口快速填充。如果在新的TCP连接上发出多个请求，这可能会导致延迟过大。

HTTP/2通过定义HTTP的语义到底层连接的`优化映射`来解决这些问题。 具体来说， 
* 它允许在同一连接上交织请求和响应消息，并对HTTP头字段使用高效编码。 
* 它还可以优先处理请求，让更重要的请求更快完成，进一步提高性能。对网络更友好，可以使用更少的TCP连接, 更好地利用可用网络容量。 
* 最后，HTTP/2还可以通过使用二进制消息帧来更有效地处理消息。


## HTTP/2 协议概述

HTTP/2为HTTP语义提供了`优化传输。` HTTP/2支持HTTP/1.1的所有核心功能，但旨在以多种方式提高效率。
每种帧类型都有不同的用途。例如，

	HEADERS和DATA帧构成HTTP请求和响应的基础（第8.1节）;
	其他帧类型（如SETTINGS，WINDOW_UPDATE和PUSH_PROMISE）用于支持其他HTTP/2功能。

通过让每个HTTP请求/响应交换与其自己的流相关联来实现请求的多路复用（第5节）。流量控制和优先级确保可以有效使用多路复用流。

	流量控制（5.2节）有助于确保只有接收机可以使用的数据才能被传输。
	确定优先级（第5.3节）确保有限的资源可以首先引导到最重要的流。 

HTTP/2增加了一种新的交互模式，`服务器可以将响应推送给客户端（见第8.2节）。`服务器推送允许服务器将数据`推测性`地发送到服务器预计客户端将需要的客户端，从而针对潜在的延迟增益进行一些网络使用的交换。服务器通过综合请求来完成此操作，并将其作为`PUSH_PROMISE`帧发送。服务器然后能够在单独的流上发送对合成请求的响应。

由于连接中使用的HTTP头字段可能包含大量冗余数据，因此包含它们的帧将被压缩（见第4.3节）。这在常见情况下对请求大小具有特别有利的影响，允许将许多请求压缩成一个分组(会以表映射cs两端同步的头部字段)。


## HTTP/2

本文档中定义的协议有两个标识符。

&emsp;&emsp;字符串“`h2`”标识HTTP/2使用传输层安全性（TLS）[TLS12]的协议。 此标识符用于TLS应用层协议协商（ALPN）扩展[TLS-ALPN]字段以及识别TLS上的HTTP/2的任何地方。 “h2”字符串被串行化为一个ALPN协议标识符，作为两个八位字节序列：0x68,0x32。

&emsp;&emsp;字符串“`h2c`”标识在明文TCP上运行HTTP/2的协议。 该标识符用于HTTP/1.1升级头字段和任何标识HTTP/2 TCP的地方。 “h2c”字符串是从ALPN标识符空间中保留的，但描述了不使用TLS的协议。 谈判“h2”或“h2c”意味着使用本文档中描述的传输，安全，成帧和消息语义。


### http协议升级机制

&emsp;&emsp;在事先不知道HTTP/2的支持情况，使用HTTP升级机制。 客户端通过使用包含具有“h2c”标记的升级标题字段的HTTP/1.1请求来这样做。 这样一个HTTP/1.1请求必须包含一个`HTTP2-Settings`头部字段。

```bash
GET / HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: h2c
HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>
```

&emsp;&emsp;不支持HTTP/2的服务器可以响应该请求，就好像升级标题字段不存在一样：

```bash
HTTP/1.1 200 OK
Content-Length: 243
Content-Type: text/html
...
```

&emsp;&emsp;支持HTTP/2的服务器接受使用`101（交换协议）`响应的升级。 在终止`101`响应的空行之后，服务器可以开始发送HTTP/2帧。这些帧必须包含对启动升级的请求的响应。

```bash
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: h2c

[ HTTP/2 connection ...
```

>也就是说在协议交换过程中，两种协议是混合使用的。

&emsp;&emsp;服务器发送的第一个HTTP/2帧必须是一个服务器`连接前置`（第3.5节），包含一个`SETTINGS帧`（6.5节）。一旦收到101响应，客户端必须发送一个`连接前言`（3.5节），其中包括一个SETTINGS帧。在升级之前发送的HTTP/1.1请求的默认优先级值（见第5.3.5节）被分配了1的流标识符（见第5.1.1节）。由于请求是作为HTTP/1.1请求完成的，所以流1从客户端向服务器隐含“`半关闭`”（请参见第5.1节）。在开始HTTP/2连接之后，流1用于响应。



### HTTP2-Settings 头部字段

一个从HTTP/1.1升级到HTTP/2的请求必须包含一个“`HTTP2-Settings`”标题字段。

&emsp;&emsp;`HTTP2-Settings`标头字段是一个特定于连接的标头字段，其中包含管理HTTP/2连接的参数，这是在服务器接受升级请求的前提下提供的。 
如果此标题字段不存在或者存在多个标题字段，则服务器不得将连接升级到HTTP/2。 服务器不能发送这个头域。 HTTP2-Settings标头字段的内容是SETTINGS帧的有效载荷（6.5节），编码为base64url字符串（即[RFC4648]的第5节中描述的URL和文件名安全的Base64编码）尾部’=’字符省略）。 “token68”的ABNF [RFC5234]生产在[RFC7235]的第2.1节中定义。 
`由于升级只适用于直接连接，发送HTTP2-Settings标头字段的客户端务必在Connection标头字段中发送“HTTP2-Settings”作为连接选项，以防止它被转发 （参见第6.1节[RFC7230]）。`

&emsp;&emsp;服务器将解码和解释这些值，就像其他任何`SETTINGS`帧一样。显式确认这些设置（第6.5.3节）不是必需的，因为101响应用作隐式确认。在升级请求中提供这些值使客户有机会在从服务器接收任何帧之前提供参数(但必须在101响应之后)。


### 预备知识

&emsp;&emsp;客户可以通过其他方式了解到特定的服务器支持HTTP/2。 例如，[ALT-SVC]描述了一种广告此功能的机制。 客户端必须发送连接前言(connection preface)（第3.5节），然后可以立即发送HTTP/2帧到这样的服务器; 服务器可以通过连接前言来识别这些连接。 这只影响通过明文TCP建立HTTP/2连接; 通过TLS支持HTTP/2的实现必须使用TLS [TLS-ALPN]中的协议协商。 同样，服务器必须发送连接前言（第3.5节）。 如果没有附加信息，事先对HTTP/2的支持并不是一个强有力的信号，即给定的服务器将支持HTTP/2用于将来的连接。 例如，可以更改服务器配置，使群集服务器中的实例之间的配置不同，或者更改网络条件。

### 连接前言

&emsp;&emsp;在HTTP/2中，每个端点都需要发送一个连接前言作为正在使用的协议的最终确认，并建立HTTP/2连接的初始设置。客户端和服务器都发送不同的连接前言。客户端连接前言以24个八比特组序列开头，十六进制表示法是：

	0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a

也就是说，连接前言以字符串“`PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n`”开头。 

这个序列后面必须紧跟一个设置帧，它可能是空的。


客户端在接收到101（交换协议）响应（指示成功升级）或作为TLS连接的第一个应用数据八位字节时立即发送客户端连接前缀。

如果在事先知道服务器支持该协议的情况下启动HTTP/2连接，则在建立连接时发送客户端连接前缀。

注意：选择客户端连接前言是为了让大部分HTTP/1.1或HTTP/1.0服务器和中间服务器不会尝试处理更多的帧。请注意，这并没有解决[TALKING]中提出的问题。

服务器连接前言包含一个可能为空的SETTINGS帧（第6.5节），必须是服务器在HTTP/2连接中发送的第一帧。发送连接前言后，必须确认从对等方接收到的作为连接前缀一部分的设置帧（参见第6.5.3节）。

&emsp;&emsp;为了避免不必要的延迟，客户端可以在发送客户端连接前言后立即向服务器发送额外的帧，而不必等待接收服务器连接前言。 
然而，需要注意的是，服务器连接前置设置框架可能包含参数，这些参数必然会改变客户端与服务器的通信方式。 在收到设置框架后，客户需要遵守已建立的任何参数。 在某些配置中，服务器可能会在客户端发送其他帧之前传输设置，从而为避免此问题提供机会。 
客户端和服务器必须将一个无效的连接前缀视为PROTOCOL_ERROR类型的连接错误 
GOAWAY框架（6.8节）在这种情况下可以省略，因为无效前言表明对等方没有使用HTTP/2。



## HTTP 帧

一旦建立了HTTP/2连接，端点就可以开始交换帧。

### 帧格式

所有帧以一个固定的9个八位组首标开始，后跟一个可变长度的有效载荷。帧头的字段定义为：

    +-----------------------------------------------+
     |                 Length (24)                   |
     +---------------+---------------+---------------+
     |   Type (8)    |   Flags (8)   |
     +-+-------------+---------------+-------------------------------+
     |R|                 Stream Identifier (31)                      |
     +=+=============================================================+
     |                   Frame Payload (0...)                      ...
     +---------------------------------------------------------------+


- Length：帧有效载荷的长度，表示为无符号的24位整数。除非接收方为SETTINGS_MAX_FRAME_SIZE设置了较大的值，否则不得发送大于2 ^ 14（16,384）的值。帧头的9个八位字节不包含在该值中。
- Type：帧的8位类型。帧类型决定帧的格式和语义。实现必须忽略并丢弃任何类型未知的帧。
- Flags：为帧类型专用的布尔标志保留的8位字段。标志被分配特定于指定帧类型的语义。没有为特定帧类型定义语义的标志务必被忽略，并且在发送时务必保持未设置（0x0）。
- R：保留的1位字段。该位的语义是未定义的，并且该位必须在发送时保持未设置（0x0），并且在接收时必须忽略。
- Stream Identifier：流标识符（见第5.1.1节）表示为一个无符号的31位整数。值0x0保留给与整个连接相关联的帧，而不是单个流。

`帧有效载荷的结构和内容完全取决于帧类型。`


### 帧大小

&emsp;&emsp;帧有效载荷的大小受到接收机在`SETTINGS_MAX_FRAME_SIZE`设置中通告的最大大小的限制。 
该设置可以为包含`2 ^ 14（16,384）和2 ^ 24-1（16,777,215）`个八位字节之间的任何值。所有的实现都必须能够接收和最小化长度为`2 ^ 14`个八位字节的帧，再加上9个八位字节的帧头（4.1节）。描述帧大小时不包括帧头的大小。


	注意：某些帧类型（如PING（6.7节））会对允许的有效载荷数据量施加额外的限制。

&emsp;&emsp;如果帧超过了在SETTINGS_MAX_FRAME_SIZE中定义的大小，超过了为帧类型定义的任何限制，或者太小而不能包含强制帧数据，则端点必须发送FRAME_SIZE_ERROR的错误代码。帧中的帧大小错误可能会改变整个连接的状态，必须将其视为连接错误（见第5.4.1节）。这包括任何携带标题块（第4.3节）（即HEADERS，PUSH_PROMISE和CONTINUATION），SETTINGS以及流标识符为0的任何帧的帧。端点不必使用帧中的所有可用空间。通过使用小于允许的最大尺寸的框架可以提高响应能力。发送较大的帧可能会导致发送对时间敏感的帧（如RST_STREAM，WINDOW_UPDATE或PRIORITY）的延迟，如sssss0果传输较大的帧，则会影响性能。



