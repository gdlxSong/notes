---
title: WAL
sidebar_position: 34
---


> 通过 WAL 可以实现 ACID 中的 A 和 D。

> golang: https://github.com/tidwall/wal


预写日志（WAL，Write-Ahead Log）将每次状态更新抽象为一个命令并追加写入一个日志中，这个日志只追加写入，也就是顺序写入，所以 IO 会很快。相比于更新存储的数据结构并且更新落盘这个随机 IO 操作，写入速度更快了，并且也提供了一定的持久性，也就是数据不会丢失，可以根据这个日志恢复数据。


### 背景介绍

如果遇到了服务器存储数据失败，例如已经确认客户端的请求，但是存储过程中，重启进程导致真正存储的数据没有落盘，在重启后，也需要保证已经答应客户端的请求数据更新真正落盘成功。

![wal-append.jpg](/images/wal-append.jpg)


将每一个更新，抽象为一个指令，并将这些指令存储在一个文件中。每个进程顺序追加写各自独立的一个文件，简化了重启后日志的处理，以及后续的在线更新操作。每个日志记录有一个独立 id，这个 id 可以用来实现分段日志（Segmented Log）或者最低水位线（Low-Water Mark）清理老的日志。日志更新可以使用单一更新队列（Singular Update Queue）这种设计模式。





### 分割日志（Segmented Log）

单一的日志文件可能会增长到很大，并且在程序启动时读取从而成为性能瓶颈。老的日志需要定时清理，但是对于一个大文件进行清理操作很费劲。将大文件切分为更容易处理的多个更小的文件。

kafka 日志使用了 分段切割：

![wal-sehment1.jpg](/images/wal-sehment1.jpg)


pulsar 数据存储 bookeeper采用日志切割：

![wal-segment2.jpg](/images/wal-segment2.jpg)



### 最低水位线（Low-Water Mark）

最低水位线是指在 WAL（Write Ahead Log）预写日志这种设计模式中，标记在这个位置之前的日志可以被丢弃。

> 问题背景: WAL（Write Ahead Log）预写日志维护了对于存储的每次更新，随着时间不断增长，这个日志文件会变得无限大。Segmented Log 分割日志这种设计模式可以让我们每次只处理一个更小的文件，但是日志如果不清理，会无休止增长以至于硬盘被占满。


#### 解决方案

最低水位线这种设计模式会告诉系统哪一部分的日志可以被删除了，即在最低水位线之前的所有日志可以被清理掉。一般的方式是，程序内有一个线程运行一个定时任务，不断地检查哪一部分的日志可以被清理并且删除这些日志文件。

**基于快照的最低水位线实现：**

大部分的分布式一致性系统（例如 Zookeeper（ZAB 简化 paxos协议），etcd（raft协议）），都实现了快照机制。在这种机制下，他们的存储引擎会定时的进行全量快照，并且记录下快照对应的日志位置，将这个位置作为最低水位线。


**基于时间的最低水位线实现：**

在某些系统中，日志不是用来更新系统的状态，可以在一段时间之后删除，并且不用考虑任何子系统这个最低水位线之前的是否可以删除。例如，kafka 默认保留 7 天的 log，RocketMQ 默认保留 3 天的 commit log。

